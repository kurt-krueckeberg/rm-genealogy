
== Analysis of RootsMagic 8 Tables Related to Persons, Names, and Relationships

RootsMagic uses a custom-defined collation sequence `RMNOCASE` (Roots Magic No Case), which https://sqlitetoolsforrootsmagic.com/RMNOCASE-faking-it-in-SQLite-Expert-command-line-shell-et-al/[SQLite Tools for RootsMagic]
discusses https://sqlitetoolsforrootsmagic.com/RMNOCASE-faking-it-in-SQLite-Expert-command-line-shell-et-al/[here], for several text fieldx like `NameTable.Surname` and `NameTable.Given`. It can prevent queries from succeeding. One work around is to force the text to lower case; for example, `lower(Surname)` is
used in the `order by` clause below:

[source, sql]
----
select n.Surname as surname, n.Given as given, p.Sex as Sex from NameTable as n join PersonTable as p on p.PersonID=n.OwnerID where n.IsPrimary=1 order by lower(Surname), OwnerID, NameID;
----

=== todo

- Create (in new db) a "unknown" person that has PersonID of 0 and possibly name of "Unknown". This would allow keys that function as links but are not defined as foreign keys, to function as foreign keys.
- Does creating an index `Create Index ...` on a table column imply that it is `UNIQUE`? If so, I need to note this if I want to mimic in MariaDB, the same thing. Doesn't the Data Definitions spreadsheet note this with `I`, too?
  *Thus, I probablu should redo the indexed colums in each table.*
- See todo below. Finishing the media tables section and the family table analysis to create queries to get families..parents, sibling, child of the parents, etc.
- ??

=== PersonTable

==== Predicate
`PersonTable` has `PersonID` key that identifies a unique individual (in the family tree) with sex `Sex`, unique `UniqueID` (that apparently is a `GUID` or hash value that is a **GEDCOM** standard field),
parent(s) `ParentID`, spouse `SpouseID` is almost always zero. When it isn't, it functions like a foreign key referencing `FamilyTable.familyID`. 

 .PersonTable
[width="99%"]
|===
|PersonID Int (Prim Key) |UniqueID TEXT |Sex Int |ParentID Int |SpouseID Int |Color Int |Relate1 Int |Relate2 Int
|Flags Int |Living Int |IsPrivate Int |Proof Int |Bookmark Int |Note TEXT |UTCModDate Float
|===

==== Comments

- `Sex` is defined as an int but used as a boolean: `0` if male, and `1` if female.
- `ParentID` is often zero. The data definition spreedsheet says:

----
Parent Identification Number, linking to FamilyID of FamilyTable, (0 if no parents) [MRIN of one set of parents, possibly last active in Pedigree view or when selected via Parents Status Bar, others?]
----

Comment: So is it a foreign key to FamilyTable.FamilyID. Write some queries to find out. If it can be zero, should I create a FmailyTable.FamilyID of 0, to mean the not-yet known family?

- `SpouseID` is almost always zero. When not zero, it functions like a foreign key referencing `FamilyTable.FamilyID`. In the referenced `FmailyTable` row, `FatherID` or `MotherID` will be 
   the spouse of `PersonID`. But `SpouseID` is not necessary in determing the family that this person is a child of (or a parent of).
- `Living` is boolean 
- `Color`
  from "color coding" screen ( 0 = None,  1 = Red,  2 = Lime,  3 = Blue,  4 = Fuschia,  5 = Yellow,  6 = Aqua,  7 = Silver,  8 = Maroon,  9 = Green, 10 = Navy, 11 = Purple, 12 = Brown, 13 = Teal, 14 = Gray)
- `Relate1`
  number of generations from person to ancestor in common with person chosen via Tools -> Set Relationships. See the "Relationship1&2" spreadsheet for exceptions and further explanation. Not relevant.
- `Relate2`
  number of generations from person chosen via Tools -> Set Relationships to ancestor in common with person. See Relationship1&2 sheet for exceptions and further explanation. Not relevant.
- `Flags`
  not currently used?
- `IsPrivate`
  not currently used?
- `Proof`
  not currently used?
- `Note`
  A note entered from Edit Person screen

=== NameTable

==== Predicate
The `NameTable.NameID` key identifies a unique name with surname `Surname` and given name `Given`, with `OwnerID` (a foreign key) referring to `PersonTable.PersonID`, the name's owner.
`BirthYear` and `DeathYear` are attributes unrleated to the table's predicate, which are present for historical reasons, cached here so `EventTable` didn't need to be queried in the days when computer speed was slow
and memory low. However, this prevents normalizing the table because the same birth and date years are repeated in every row with the same `OwnerID`. To confirm this is the case, consider these two queries 

[source, sql]
----
SELECT OwnerID, count(*) as total_names from NameTable group by OwnerID having total_names > 1 order by OwnerID;
----

and

[source, sql]
----
SELECT OwnerID, BirthYear,DeathYear, count(*) as tuple_total from NameTable group by OwnerID, BirthYear, DeathYear having tuple_total > 1
----

The first select rows for persons with more than one name assigned to them. The second query selects rows where any of three attributes *OwnerID, BirthYear or DeathYear* ever diifer. Both queries return the exactly the same 
results. If their results are joined on `OwnerID` and filtered by a *where clause* where the total number of names is not equal to the total number of the unique groupings of *OwnerID, BirthYear, and DeathYear*.
The query always returns nothing:

[source, sql]
----
select r1.OwnerID, total_names, r2.BirthYear, r2.DeathYear, tuple_total
 from 
 (SELECT OwnerID, count(*) as total_names from NameTable group by OwnerID having total_names > 1) as r1
    join
 (SELECT OwnerID, BirthYear,DeathYear, count(*) as tuple_total from NameTable group by OwnerID, BirthYear, DeathYear having tuple_total > 1) as r2
    on r1.OwnerID=r2.OwnerID
 WHERE total_names!=tuple_total;
----

Other self-descriptiive attributes are `Prefix`, `Suffix` and `Nickname`. `IsPrimary` is 1 if it the primary name and 0 if it is an alternate name.

*Note*: The surname can be empty. The BirthYear of DeathYear can be zero, meaning they are unkown.

.NameTable
[width="99%",cols="17%,3%,4%,3%,3%,3%,4%,4%,3%,5%,4%,4%,3%,4%,3%,4%,4%,3%,4%,5%,4%,4%,5%",]
|===
|NameID Int (Prim Key) |OwnerID Int |Surname TEXT |Given TEXT |Prefix TEXT |Suffix TEXT |Nickname TEXT |NameType Int |Date TEXT |SortDate
BigInt |IsPrimary Int |IsPrivate Int |Proof Int |Sentence TEXT |Note TEXT |BirthYear Int |DeathYear Int |Display Int |Language TEXT
|UTCModDate Float |SurnameMP TEXT |GivenMP TEXT |NicknameMP TEXT
|===

==== Queries
Select the primary name, birth and death years and sex.

[source, sql]
----
select n.Surname as surname, n.Given as given, n.BirthYear as birth_year, n.DeathYear as death_year, p.Sex as Sex from NameTable as n join PersonTable as p on p.PersonID=n.OwnerID where n.IsPrimary=1 order by lower(Surname), OwnerID, NameID;
----

Include keys and foreign keys:

[source]
----
select n.Surname as surname, n.Given as given, n.BirthYear as birth_year, n.DeathYear as death_year, p.Sex as Sex, n.OwnerID as OwnerId, n.NameID as NameId from NameTable as n join PersonTable as p on p.PersonID=n.OwnerID where n.IsPrimary=1 order by lower(Surname), OwnerID, NameID;
----

==== todo

Create a the sql that queries the EventTable to get the birth and death year and use it above instead of the NameTable.

=== ChildTable 

The `ChildTable` stores relationship to family(ies) for each child. A child may have two or more families, say, a birth and adoptive family. This table provides the links to `PersonTable.PersonID` for the child and to FamilyTable for their parents.

`ChildTable` has key `RecID`, child identifier `ChildID`, a foreign key referencing the `PersonTable.PersonID`, and `FamilyID`, a foreign key referencing `FamilyTable.FamilyID`. 

Comments: The queries below show that ChildID is an actual foreign key. It is never zero, and the row count of ChildTable equals the row count of the join of ChildTable to PersonTable on childID=PersonID.

[source]
----
sqlite> select count(*) from ChildTable as c join PersonTable p on c.ChildID=p.PersonID;
2147
sqlite> select count(*) from ChildTable;
2147
sqlite> select count(*) from ChildTable as c join PersonTable p on c.ChildID=p.PersonID;
2147
----

- `ChildID` foreign key referencing in `PersonTable.PersonID`.
- `FamilyID` references `FamilyTable.FamilyID` or Marriage Record Identication Number (MRIN). 
- `RelFather` the relationship to the father: 0-Birth,1-Adopted, 2- Step,etc
- `RelMother` the relationship to mother: 0-Birth,1-Adopted, 2- Step,etc
- `ChildOrder` 0 means in record order; 1,2,... revises the order for the family but 1000 also observed for child added w/o birthdate, and 501 sometimes noted when no other children in family.

These next three attributes are important:

- `IsPrivate` 0 or 1.	1 if Private checked in Parents pane of Edit Person dialog. Effect on reports is not apparent.
- `ProofFather` 0,1,2,3	Set by Proof listbox in Parents pane of Edit Persons. 0-blank, 1-Proven, 2-Disproven, 3-Disputed
- `ProofMother` 0,1,2,3	Set by Proof listbox in Parents pane of Edit Persons. 0-blank, 1-Proven, 2-Disproven, 3-Disputed
- `Note` unused?

.ChildTable
[width="97%",cols="16%,14%,14%,14%,14%,14%,14%",]
|===
|RecID Int (Prim Key) |ChildID Int |FamilyID Int |RelFather Int |RelMother Int |Chi ldOrder Int |Is Private Int
|===

==== Comments
All children with the same `FamilyID` have the same set of parents.  Not every `PersonID` appears in the `ChildTable`. Not every person has at least one parent; for example,
the olders ancestors don't have assigned parents.

The ChildTable has only 2047 rows. Thus only 2047 ChildIDs (which is a foreign key referencing PersonTable) out of 3086 occur in the ChildTable.

Can a child belong to more than one family? And what if a person does not yet have any or both assigned parents. In this case, there should be no entry for them in the `ChildTable` or `FamilyTable`.

select 
Question: 
The unique pair `FatherID` plus `MotherID` can have zero or more children (I believe). I doubt that a child is required to constitute a family, but this predicate for `FamilyTable` has not been verified.
Genealogical software does not, in general, does not directly concern itslef with issues like whether the offspring of a realtionship ever live with or grow up with their parents.

=== FamilyTable

`FamilyTable` has `FamilyID` key identifying each unique family, each couple that might (has?) produced children. `FatherID` and `MotherID` function like foreign keys referencing `PersonTable.PersonID`, but they
can be zero, meaning, I believe, that that parent is unknown. It is never true that both `FatherID` and `MotherID` are zero. Thus,

[source, sql]
----
select * from FamilyTable where FatherID=0 and MotherID=0;
----

will never return results. `ChildID` is almost always 0, so I don't know what it means. It references PersonID in a few rarer situations.

Question:

- For each couple, a "husband" and "wife" (or non-married couple), represented by their separate PersonID's in the PersonTable, link to the same row in the FamilyTable?  
- *{HusbandID, MotherID}* is a key-is it not?

.FamilyTable
[width="99%",cols="18%,5%,5%,4%,5%,5%,5%,4%,6%,6%,6%,7%,7%,7%,4%,6%",]
|===
|FamilyID Int (Prim Key) |FatherID Int |MotherID Int |ChildID Int |HusbOrder Int |WifeOrder Int |IsPrivate Int |Proof Int |SpouseLabel Int
|FatherLabel Int |MotherLabel Int |SpouseLabelStr TEXT |FatherLabelStr TEXT |MotherLabelStr TEXT |Note TEXT |UTCModDate Float
|===

- `FamilyID` primary key
- `FatherID` foreign key referencing `Person.TablePersonID` 
- `MotherID` foreign key referencing `Person.TablePersonID`
- `ChildID` id referencing `Person.TablePersonID`. 0 if no children exist.[RIN of one of children, possibly last active in Pedigree view, others?]
- `HusbOrder` husband order from rearrange spouses screen. 0 if never rearranged. [There are some oddities, such as value of 2, but only one husband?]
- `WifeOrder` wife order from rearrange Spouses screen (0 if never rearranged) [some oddities such as value of 2, but only one wife?]
- `IsPrivate` Private from Edit Person screen (0 = Not Private (unchecked), 1 = Private (checked))
- `Proof` Proof from Edit Person screen (0 = [blank], 1 = Proven, 2 = Disproven, 3 = Disputed)
- `SpouseLabel` not currently supported?
- `FatherLabel` husband label set from Edit Person screen (0 = Father, 1 = Husband, 2 = Partner).
- `MotherLabel` Wife label, from Edit Person screen (0 = Mother, 1 = Wife, 2 = Partner).
- `Note` Note from Edit Person screen

=== Media Tables todo 

== Conversion to JSON and XML
The https://github.com/FamilySearch/gedcom5-java[gedcom5-java] FamilySearch github repo has a `Gedcom2Json` convertor. It explains how to compile it using maven. Run it:

[source,bash]
----
$ java -cp target/gedcom.jar org.folg.gedcom.tools.Gedcom2Json -i k.ged -o k.json 
----

== Analysis of Tables Related to Downloaded Ancestry Media Files

== Todoes

=== DB Questions to Figure Out

Figure out if "family" means there must be a child. To test this use my Frankenstein tree. Give a wife to the son, but give them no children, expert and import to rootsmagic.
And create a SQL join statment, left or right join, to determine if there persons with no parents.

SQL to show persons with no children is also desired.

=== Ancestry Medis Files

Incorporate my notes for assigning Ancestry Media Gallery files to the correct person.

=== New DB with Forign Key Contraints

After figure out the question above, dump the Rootsmagic db and import it into a new DB that has the foreign key contraints described above.

=== Other 

- Look into an alternate solution of:

  - Github FamilySearch Converting GEDCOM 5 to GECOM X, and then

  - Github FamilySearch GEDCOM 5 Parser

  - Using Github FamilySearch PHP Gecom X library to extract the details.

- Look into Webtrees and its tables.

